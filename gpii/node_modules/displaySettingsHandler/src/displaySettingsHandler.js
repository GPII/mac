/*
 * macOS Display Settings Handler
 *
 * Copyright 2016-2020 Raising the Floor -- US Inc. All rights reserved.
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 * 
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 */

"use strict";

var fluid = require("gpii-universal");

var gpii = fluid.registerNamespace("gpii");
var macos = fluid.registerNamespace("gpii.macos");

fluid.registerNamespace("gpii.macos.display");
fluid.registerNamespace("gpii.macos.displaySettingsHandler");

// The OS specific files can only be loaded from within the OS is it intended for.
require("./dpiMacOS.js");

// /*
//  * Returns if a screen resolution is invalid
//  *
//  * @param (Object)
//  * @returns {Boolean} true if invalid
//  */
// macos.display.isInvalid = function (screenRes) {
//     var isInvalid = true;
//     if (typeof(screenRes.width) === "number" && typeof(screenRes.height) === "number" && screenRes.width > 0 && screenRes.height > 0) {
//         fluid.each(macos.display.getAvailableResolutions(), function (validScreenRes) {
//             if (validScreenRes.width === screenRes.width && validScreenRes.height === screenRes.height) {
//                 isInvalid = false;
//             };
//         });
//     }
//     return isInvalid;
// };

/*
 * Gets the current display's screen resolution
 *
 * @return {Object) The width and height of the screen.
 */
macos.display.getScreenResolution = function () {
    var currentDisplayMode = gpii.macos.native.getCurrentDisplayMode();
    if (currentDisplayMode) {
        return {
            width: currentDisplayMode.widthInVirtualPixels,
            height: currentDisplayMode.heightInVirtualPixels
        };
    } else {
        fluid.fail("Couldn't retrieve the current screen resolution");
    }
};

// /*
//  * Gets available display modes (including display mode id, resolution and virtual resolution info, etc.)
//  *
//  * @return {list} of display modes
//  */
macos.display.getAvailableDisplayModes = function() {
    // get a list of all valid display modes for the main display
    var allDisplayModes = gpii.macos.native.getAllDisplayModes();

    // filter out any display modes which are marked as not usable for a desktop GUI
    var usableForDesktopGuiDisplayModes = macos.display.filterOutUnusableForDesktopGuiDisplayModes(allDisplayModes);

    // sort list of display modes (by width primarily, then height secondarily) in order of increasing size
    var sortedDisplayModes = macos.display.sortDisplayModesByResolutionAscending(usableForDesktopGuiDisplayModes);

    // remove duplicate display mode entries
    var deduplicatedDisplayModes = macos.display.filterOutDuplicateDisplayModes(sortedDisplayModes);

    // remove all non-retina display mode options which have a corresponding retina display mode option
    var retinaPreferredDisplayModes = macos.display.filterOutNonRetinaScaleAlternativeDisplayModes(deduplicatedDisplayModes);

    // remove all retina "native" resolution options where a pixel-doubled retina option exists
    var pixelDoublePreferredDisplayModes = macos.display.filterOutRetinaNativeScaleDisplayModes(retinaPreferredDisplayModes);

    // return the filtered list of display modes
    return pixelDoublePreferredDisplayModes;
}

// /*
//  * Gets the default display mode
//  *
//  * @return the default display mode
//  */
macos.display.getDefaultDisplayMode = function() {
    // NOTE: this function assumes that the retina variant of the highest screen resolution is the "default" resolution, as Apple no longer
    //       provides non-deprecated APIs or fixed critera for what they consider the "default" resolution (as shown in System Preferences)
    //       in the alternate, we could call CGDisplayScreenSize and do some DPI calculations ourselves...based on custom criteria

    // get a list of all valid display modes for the main display
    var allDisplayModes = gpii.macos.native.getAllDisplayModes();
 
    // filter out any display modes which are marked as not usable for a desktop GUI
    var usableForDesktopGuiDisplayModes = macos.display.filterOutUnusableForDesktopGuiDisplayModes(allDisplayModes);

    // retrieve the highest-resolution native display mode from our list of available display modes
    var highestResolutionNativeDisplayMode = macos.display.getHighestResolutionNativeDisplayMode(usableForDesktopGuiDisplayModes);

    // get a filtered list of all display modes (minus the unusable-for-gui, non-retina, etc. modes)
    var availableDisplayModes = macos.display.getAvailableDisplayModes()

    var defaultDisplayMode = null;

    // find the available display mode which matches our highestResolutionNativeDisplayMode's native resolution (widthInPixels/heightInPixels)
    availableDisplayModes.forEach(function(displayMode) {
        if (displayMode.widthInPixels == highestResolutionNativeDisplayMode.widthInPixels &&
            displayMode.heightInPixels == highestResolutionNativeDisplayMode.heightInPixels) {
            //
            defaultDisplayMode = displayMode;
        }
    });

    // failsafe: if our highest-resolution native display mode was somehow filtered, then return the final available display mode instead
    if (defaultDisplayMode == null && availableDisplayModes.length > 0) {
        defaultDisplayMode = availableDisplayModes[availableDisplayModes.length - 1];
    }

    return defaultDisplayMode;
}

/*
 * Gets available resolutions
 *
 * @return {list} of resolutions
 */
macos.display.getAvailableResolutions = function () {
    var index = 0;
    var availableResolutions = [];

    var availableDisplayModes = macos.display.getAvailableDisplayModes();

    availableDisplayModes.forEach(function(entry) {
        var displayResolution = {
            width: entry.widthInPixels,
            height: entry.heightInPixels
        };
        availableResolutions.push(displayResolution);
    });

    fluid.log("macos.display.getAvailableResolutions got available screen resolutions ", availableResolutions);

    return availableResolutions;
};

/*
 * Sets the current display's screen resolution if possible
 *
 * @param {Object} The new screen resolution width and height
 * @return {Boolean} true if successful
 */
macos.display.setScreenResolution = function (newRes) {
    var allScreenDpisWithDisplayModes = macos.display.getAllScreenDpisWithDisplayModes(adaper);
    // sanity check
    if (!allScreenDpisWithDisplayModes || allScreenDpisWithDisplayModes.dpiDisplayModeMap.length == 0) {
        // NOTE: this code should never be executed
        return false;
    }

    // get the dpiOffset associated with this screen resolution 
    var newResDpiOffset = null;
    for(var dpiOffset = allScreenDpisWithDisplayModes.minimum; dpiOffset <= allScreenDpisWithDisplayModes.maximum; dpiOffset++) {
        var dpiOffsetAsString = dpiOffset + "";
        var displayModeAtDpiOffset = allScreenDpisWithDisplayModes.dpiDisplayModeMap[dpiOffsetAsString];
        if(displayModeAtDpiOffset.widthInVirtualPixels == newRes.width &&
            displayModeAtDpiOffset.heightInVirtualPixels == newRes.height) {
            //
            newResDpiOffset = dpiOffset;
            break;
        }
    }

    if(!newResDpiOffset) {
        fluid.fail("Received an invalid screen resolution: ", newRes);
        return false;
    } else {
        macos.display.setScreenDpi(newResDpiOffset);
        return true;
    }
};

macos.display.setImpl = function (payload) {
    var results = {};

    var targetRes = payload.settings["screen-resolution"];
    if (targetRes) {
        var oldRes = macos.display.getScreenResolution();
        var newRes = oldRes;

        if (typeof(targetRes.width) !== "number" || typeof(targetRes.height) !== "number") {
            fluid.fail("Incorrect payload for screen resolution: " +
                JSON.stringify(payload, null, 4));
        }
        else if (macos.display.setScreenResolution(targetRes)) {
            newRes = targetRes;
        }

        results["screen-resolution"] = { oldValue: oldRes, newValue: newRes };
    }

    var targetDpi = payload.settings["screen-dpi"];
    if (Number.isInteger(targetDpi)) {
        var oldDpi = macos.display.getScreenDpi();
        macos.display.setScreenDpi(targetDpi);
        results["screen-dpi"] = { oldValue: oldDpi.configured, newValue: targetDpi };
    }

    fluid.log("display settings handler SET returning results ", results);

    return results;
};

macos.display.getImpl = function () {
    var curRes = macos.display.getScreenResolution();
    var curDpi = macos.display.getScreenDpi();

    var results = {
        "screen-resolution": curRes,
        "screen-dpi": curDpi.configured
    };

    return results;
};

macos.displaySettingsHandler.get = function (payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(macos.display.getImpl, payload);
};
macos.displaySettingsHandler.set = function (payload) {
    return gpii.settingsHandlers.invokeSettingsHandler(macos.display.setImpl, payload);
};

// Sorting/filtering utilities

macos.display.sortDisplayModesByResolutionAscending = function(displayModes) {
    return displayModes.slice().sort(function(a,b) {
        // sort index: widthInVirtualPixels
        if (a.widthInVirtualPixels > b.widthInVirtualPixels) {
            return 1;
        } else if (a.widthInVirtualPixels < b.widthInVirtualPixels) {
            return -1;
        }

        // sort index: heightInVirtualPixels
        if (a.heightInVirtualPixels > b.heightInVirtualPixels) {
            return 1;
        } else if (a.heightInVirtualPixels < b.heightInVirtualPixels) {
            return -1;
        }

        // sort index: widthInPixels
        if (a.widthInPixels > b.widthInPixels) {
            return 1;
        } else if (a.widthInPixels < b.widthInPixels) {
            return -1;
        }

        // sort index: heightInPixels
        if (a.heightInPixels > b.heightInPixels) {
            return 1;
        } else if (a.heightInPixels < b.heightInPixels) {
            return -1;
        }

        // otherwise, the values are equal
        return 0;
    });
}

macos.display.filterOutDuplicateDisplayModes = function(displayModes) {
    // copy the whole displayModes array into a working set
    let workingSet = displayModes.slice();
    
    // NOTE: this filter routine would be much faster if we pre-sorted the array; for simplicity we do not do so here
    
    let iFirstElement = 0;
    while (iFirstElement < workingSet.length) {
        let iSecondElement = iFirstElement + 1;
        while (iSecondElement < workingSet.length) {
            if (macos.display.displayModesAreEqual(workingSet[iFirstElement], workingSet[iSecondElement]) == true) {
                workingSet.splice(iSecondElement, 1);
            } else {
                iSecondElement += 1;
            }
        }
        
        iFirstElement += 1;
    }
    
    // return the remaining (non-duplicate) working set entries
    return workingSet;
}

macos.display.filterOutUnusableForDesktopGuiDisplayModes = function(displayModes) {
    // remove all display modes where ".isUsableForDesktopGui" is set to false 

    return displayModes.slice().filter(function(a) {
        return a.isUsableForDesktopGui == true;
    });    
}

macos.display.filterOutNonRetinaScaleAlternativeDisplayModes = function(displayModes) {
    // remove all non-retina display mode options which have a corresponding retina display mode option
    
    // copy the whole displayModes array into a working set
    let workingSet = displayModes.slice();

    let iFirstElement = 0
    while (iFirstElement < workingSet.length) {
        let firstElementWasRemoved = false;
        
        let iSecondElement = iFirstElement + 1;
        while (iSecondElement < workingSet.length) {
            let secondElementWasRemoved = false;
            
            if (workingSet[iFirstElement].widthInVirtualPixels == workingSet[iSecondElement].widthInVirtualPixels &&
                workingSet[iFirstElement].heightInVirtualPixels == workingSet[iSecondElement].heightInVirtualPixels) {
                // the two entries are the same virtual resolution (i.e. what the user sees in the resolution options)
                
                // remove the option which is non-retina
                if (workingSet[iFirstElement].widthInPixels > workingSet[iSecondElement].widthInPixels &&
                    workingSet[iFirstElement].heightInPixels > workingSet[iSecondElement].heightInPixels) {
                    // the first entry is the higher-resolution entry; remove the second element
                    workingSet.splice(iSecondElement, 1);

                    // mark "secondElementWasRemoved" as true so it won't be incremented at the end of the current loop iteration
                    secondElementWasRemoved = true;
                } else {
                    // otherwise, remove the first element
                    workingSet.splice(iFirstElement, 1);
                    
                    // mark "firstElementWasRemoved" as true so that it won't be incremented at the end fo the current (outer) loop iteration
                    firstElementWasRemoved = true;
                    // break out the of the loop so that we start re-seeking at the next "first element" position
                    break;
                }
            }

            if (secondElementWasRemoved == false) {
                // NOTE: we only increment iSecondElement if the second element was NOT removed; otherwise we need to continue processing at the same position
                iSecondElement += 1;
            }
        }
        
        if (firstElementWasRemoved == false) {
            // NOTE: we only increment iFirstElement if the first element was NOT removed; otherwise we need to continue processing at the same position
            iFirstElement += 1;
        }
    }
    
    // return the remaining ("non-retina mode option removed where matching retina mode was present") working set entries
    return workingSet;
}

macos.display.getHighestResolutionNativeDisplayMode = function(displayModes) {
    // get the display mode with the highest resolution which is based on a native display mode
    // NOTE: this distinction basically means we are filtering out any display modes which use a fake "widthInPixels/heightInPixels" pair with
    //       a virtual resolution which is less than the actual resolution; on macOS these are the "more space" options which shrink the 
    //       "Retina" display to a less-than-pixel-doubled virtual resoluiton

    var highestResolutionNativeDisplayMode = null;

    // copy the whole displayModes array into a working set
    let workingSet = displayModes.slice();

    workingSet.forEach(function(element) {
        if (element.widthInPixels == element.widthInVirtualPixels &&
            element.heightInPixels == element.heightInVirtualPixels) {
                // the entry is a native resolution
                if (highestResolutionNativeDisplayMode == null) {
                    highestResolutionNativeDisplayMode = element 
                } else {
                    // NOTE: we are calculating a resolution as "higher" than the previous ones if both its width and height are greater than
                    //       or equal; we use >= rather than > in case two resolutions have the same width but different heights, etc.
                    // NOTE: this is an imperfect calculation (if the display offers non-native aspect ratios), but it is practical; we may
                    //       choose to revise this (and the sort routines) using a common "isHigherResolution" function in the future
                    if (element.widthInPixels >= highestResolutionNativeDisplayMode.widthInPixels &&
                        element.heightInVirtualPixels >= highestResolutionNativeDisplayMode.heightInPixels) {
                        //
                        highestResolutionNativeDisplayMode = element 
                    }
                }
            }
    });

    return highestResolutionNativeDisplayMode;    
}

macos.display.filterOutRetinaNativeScaleDisplayModes = function(displayModes) {
    // remove all retina display mode options that are "native resolution" (versus the ones that use pixel doubling)
    
    // copy the whole displayModes array into a working set
    let workingSet = displayModes.slice();
    
    let iFirstElement = 0;
    while (iFirstElement < workingSet.length) {
        let firstElementWasRemoved = false;
        
        let iSecondElement = iFirstElement + 1;
        while (iSecondElement < workingSet.length) {
            let secondElementWasRemoved = false;
            
            if (workingSet[iFirstElement].widthInPixels == workingSet[iSecondElement].widthInPixels &&
                workingSet[iFirstElement].heightInPixels == workingSet[iSecondElement].heightInPixels) {
                // the two entries are the same physical resolution
                
                // remove the option which is retina's "native" resolution (because the dots would be TOO small)
                if (workingSet[iFirstElement].widthInVirtualPixels < workingSet[iSecondElement].widthInVirtualPixels &&
                    workingSet[iFirstElement].heightInVirtualPixels < workingSet[iSecondElement].heightInVirtualPixels) {
                    // the first entry is the non-native (pixel doubled) entry; remove the second element
                    workingSet.splice(iSecondElement, 1);
                    
                    // mark "secondElementWasRemoved" as true so it won't be incremented at the end of the current loop iteration
                    secondElementWasRemoved = true;
                } else {
                    // otherwise, remove the first element
                    workingSet.splice(iFirstElement, 1);
                    
                    // mark "firstElementWasRemoved" as true so that it won't be incremented at the end fo the current (outer) loop iteration
                    firstElementWasRemoved = true;
                    // break out the of the loop so that we start re-seeking at the next "first element" position
                    break;
                }
            }
            
            if (secondElementWasRemoved == false) {
                // NOTE: we only increment iSecondElement if the second element was NOT removed; otherwise we need to continue processing at the same position
                iSecondElement += 1;
            }
        }
        
        if (firstElementWasRemoved == false) {
            // NOTE: we only increment iFirstElement if the first element was NOT removed; otherwise we need to continue processing at the same position
            iFirstElement += 1;
        }
    }
    
    // return the remaining ("non-retina mode option removed where matching retina mode was present") working set entries
    return workingSet;    
}

macos.display.displayModesAreEqual = function(displayMode1, displayMode2) {
    if (displayMode1.ioDisplayModeId != displayMode2.ioDisplayModeId ||
        displayMode1.widthInPixels != displayMode2.widthInPixels ||
        displayMode1.heightInPixels != displayMode2.heightInPixels ||
        displayMode1.widthInVirtualPixels != displayMode2.widthInVirtualPixels ||
        displayMode1.heightInVirtualPixels != displayMode2.heightInVirtualPixels ||
        displayMode1.refreshRateInHertz != displayMode2.refreshRateInHertz) {
        //
        return false;
    }

    // otherwise, the arguments are equal
    return true;
}