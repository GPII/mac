/*
 * macOS Language
 *
 * Copyright 2020 Raising the Floor -- US Inc. All rights reserved.
 * Copyright 2018 Raising the Floor - International
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 * 
 * The R&D leading to these results received funding from the
 * Department of Education - Grant H421A150005 (GPII-APCP). However,
 * these results do not necessarily represent the policy of the
 * Department of Education, and you should not assume endorsement by the
 * Federal Government.
 */

"use strict";

var fluid = require("gpii-universal");

var gpii = fluid.registerNamespace("gpii");
var macos = fluid.registerNamespace("gpii.macos");

fluid.registerNamespace("gpii.macos.language");

fluid.defaults("gpii.macos.language", {
    gradeNames: ["fluid.component", "fluid.modelComponent"],
    invokers: {
        getInstalledLanguages: {
            funcName: "gpii.macos.language.getInstalled",
            args: [ "{that}" ]
        },
        getLanguageNames: {
            funcName: "gpii.macos.language.getLanguageNames",
            args: [ "{that}", "{arguments}.0" ]
        },
        getDisplayLanguage: {
            funcName: "gpii.macos.language.getDisplayLanguage"
        },
//         startMessages: "{gpii.macos.messages}.start({that})",
//         stopMessages: "{gpii.macos.messages}.stop({that})"
    },
    listeners: {
        "onCreate.update": "{that}.getInstalledLanguages()",
//         "onCreate.messages": "{that}.startMessages()",
//         "{gpii.macos.messages}.events.onMessage": {
//             funcName: "gpii.macos.language.windowMessage",
//             // that, hwnd, msg, wParam, lParam
//             args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.3" ]
//         }
    },
    // The model gets updated whenever getInstalledLanguages is called.
    model: {
        /** @type {Map<String,InstalledLanguage>} */
        installedLanguages: null,
        /** Currently configured display language */
        configuredLanguage: null
    },
    members: {
        /** code=>name map of language names in english */
        englishNames: {}
    }
});

// /**
//  * Language names.
//  * @typedef {Object} LanguageNames
//  * @property {String} english The language name in English.
//  * @property {String} local The language name (and country), in the current display language.
//  * @property {String} native The language name (and country), in its native language.
//  */

// /**
//  * An installed language
//  * @typedef {LanguageNames} InstalledLanguage
//  * @property {String} code The language code, `lang[-COUNTRY]`.
//  * @property {Boolean} current true if this is the current display language.
//  */

/**
 * Gets the display languages that are installed on the system, and updates the model.
 *
 * These are listed in HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\MUI\UILanguages
 *
 * @param {Component} that The gpii.macos.language instance.
 * @return {Promise<Map<String,InstalledLanguage>>} A promise, resolving with either the language names if the list has
 * changed, or null if there was no change.
 */
gpii.macos.language.getInstalled = function (that) {
    var langCodes = gpii.macos.native.getInstalledAppleLanguages();

    // NOTE: on Windows, we call "gpii.windows.fixCodeCase" to ensure that the language code portion is lowercase and the country code portion
    //       is uppercase; on macOS this should not be necessary so we neither include nor call that function to postprocess "langCodes" 

    var current = gpii.macos.language.getDisplayLanguage();

    // Because this function gets called in the off-chance that the language has changed (maybe multiple times during
    // key-in), and getting the translated languages requires a new process, perform some checks upfront.
    var changed = current !== fluid.get(that.model, "configuredLanguage");
    that.applier.change("configuredLanguage", current);

    if (!changed) {
        var knownLanguages = Object.keys(fluid.get(that.model, "installedLanguages") || {});
        changed = langCodes.length !== knownLanguages.length;
        if (!changed) {
            changed = !knownLanguages.every(function (elem) {
                return langCodes.includes(elem);
            });
        }
    }

    var promise;
    if (changed) {
        // Update the language names only if required.
        promise = that.getLanguageNames(langCodes).then(function (languages) {
            that.applier.change("installedLanguages", languages);
        });
    } else {
        promise = fluid.promise().resolve();
    }

    return promise;
};

/**
 * Gets the language names of the given languages, identified by their IETF language codes (`en`, `es-MX`).
 *
 * It returns an object containing the name in English, the current display language, and native language.
 *
 * If only the language identifier (first 2 characters) are passed, then the language name is returned.
 * If the country code is also given, then the country is also returned in brackets:
 *  - If the country is code is unknown, or the country-specific language isn't recognised, then the language code is
 *     used instead of the country.
 *  - If the language is only spoken in a single country (eg, Bulgarian), then the country is not returned, unless a
 *     different country was passed (eg, bg-GB).
 * If the language is unknown, then an empty string is used. If the language code is invalid, null each field is null.
 *
 * Examples:
 *```
 * "es-MX" => { english: "Spanish (Mexico)", local: "Spanish (Mexico)", native: "Español (México)" }
 * "en" => { english: "English", local: "English", native: "English" }
 * "en-GB" => { "english": "English (United Kingdom)", "local": "English (United Kingdom)", "native": "English (United Kingdom)" }
 *```
 * When the current display language is French:
 * ```
 * "nl-NL" => { english: "Dutch (Netherlands)", local: "Néerlandais (Pays-Bas)", native: "Nederlands (Nederland)" }
 * ```
 * @param {Component} that The gpii.macos.language instance.
 * @param {String|Array<String>} langCodes The language code(s), in the form of `lang[-COUNTRY]`.
 * @return {Promise<LanguageNames>} A promise, resolving with the language names.
 */
gpii.macos.language.getLanguageNames = function (that, langCodes) {
    var promise = fluid.promise();

    var currentLangCode = gpii.macos.language.getDisplayLanguage();

    // resolve each langCode to its english, local and native names
    var languages = {};
    langCodes.forEach(langCode => {
        let languageNameInEnglishLocale = gpii.macos.native.getLanguageName(langCode, "en-US");
        let languageNameInCurrentLocale = gpii.macos.native.getLanguageName(langCode, currentLangCode);
        let languageNameInNativeLocale = gpii.macos.native.getLanguageName(langCode, langCode);
        //
        let countryNameInEnglishLocale = gpii.macos.native.getCountryName(langCode, "en-US");
        let countryNameInCurrentLocale = gpii.macos.native.getCountryName(langCode, currentLangCode);
        let countryNameInNativeLocale = gpii.macos.native.getCountryName(langCode, langCode);
        //
        let languageAndCountryNameInEnglishLocale = languageNameInEnglishLocale + " (" + countryNameInEnglishLocale + ")"
        let languageAndCountryNameInCurrentLocale = languageNameInCurrentLocale + " (" + countryNameInCurrentLocale + ")"
        let languageAndCountryNameInNativeLocale = languageNameInNativeLocale + " (" + countryNameInNativeLocale + ")"

        languages[langCode] = {
            code: langCode,
            english: languageAndCountryNameInEnglishLocale,
            local: languageAndCountryNameInCurrentLocale,
            native: languageAndCountryNameInNativeLocale
        };

        if (langCode == currentLangCode) {
            languages[langCode].currentLangCode = true;
        };

        // Save the English name
        that.englishNames[langCode] = languageAndCountryNameInEnglishLocale;
    });
    
    promise.resolve(languages);

    return promise;
};

// /**
//  * Called when an event has been received by the message window.
//  *
//  * When a relevant message is received, the installed languages model will be updated. The current language can't be
//  * changed during a session, however the drop-down list in control panel still broadcasts WM_SETTINGCHANGE.
//  *
//  * @param {Component} that The gpii.macos.language component.
//  * @param {Number} hwnd The window handle of the message window.
//  * @param {Number} msg The message identifier.
//  * #param {Number} wParam Message specific data. (unused)
//  * #param {Buffer} lParam Additional message specific data. (unused)
//  */
// gpii.macos.language.windowMessage = function (that, hwnd, msg) {
//     if (msg === gpii.macos.API_constants.WM_SETTINGCHANGE
//         || msg === gpii.macos.API_constants.WM_INPUTLANGCHANGE) {
//         that.getInstalledLanguages();
//     }
// };

/**
 * Gets the currently configured display language.
 *
 * This is the language which new processes will use.
 *
 * @return {String} The language code of the currently configured display language.
 */
gpii.macos.language.getDisplayLanguage = function () {
    var langCode = macos.native.getPrimaryInstalledAppleLanguage();
    
    // NOTE: on Windows, we call "gpii.windows.fixCodeCase" to ensure that the language code portion is lowercase and the country code portion
    //       is uppercase; on macOS this should not be necessary so we neither include nor call that function to postprocess "langCode" 

    return langCode;
};

/**
 * Updates the macOS display language, by restarting Finder and other system launch daemons and agents if the language has
 * changed since the last time this was called.
 *
 * @param {String} currentLanguage [optional] The current (new) language.
 * @return {Promise|undefined} Resolves when all daemons/agents have restarted, or null if the language has not changed.
 */
gpii.macos.updateLanguage = function (currentLanguage) {
    var lang = currentLanguage || gpii.macos.language.getDisplayLanguage();

    if (gpii.macos.updateLanguage.lastLanguage !== lang) {
        // Update the state.
        var languageInstances = fluid.queryIoCSelector(fluid.rootComponent, "gpii.macos.language");
        fluid.each(languageInstances, gpii.macos.language.getInstalled);

        var lastLanguage = gpii.macos.updateLanguage.lastLanguage;
        gpii.macos.updateLanguage.lastLanguage = lang;

        // update the system language (i.e. primary preferred language)
        // NOTE: in the future, if we have any failure scenarios for settting the primary language, we should return null to indicate failure
        macos.native.setPrimaryInstalledAppleLanguage(lang);

        // restart all appropriate launch daemons and agents
        // NOTE: since restartService is effectively asynchronous, we do not chain its execution via promises
        var restartServices = function() {
            var serviceNames = macos.native.getAllLaunchDaemonsAndAgentsAsServiceNames();
            macos.native.restartServicesViaLaunchctl(serviceNames);    
        };
        restartServices();

        var promise = fluid.promise();
        var result = {
            newValue: lang,
            oldValue: lastLanguage
        }
        // NOTE: as of 2020-02-22, the Windows setting handler does not return the new language name; we may want to consider resolving with no argument instead
        promise.resolve(result);
        return promise;
    }
};

// NOTE: in the future, we may want to consider using fluid.defaults to abstractly call our updateLanguage function instead (or use .setImpl, etc. for the language handler)
gpii.macos.updateLanguage.set = function (args) {
    var settingHandlerName = 'com.apple.macos.language';

    // verify that our settings handler's name was passed in correctly (and that it contains setttings)
    var primaryArg = args[settingHandlerName];
    if (!primaryArg || !primaryArg[0] || !primaryArg[0].settings) {
        // if our settings handler payload is missing or invalid, return null; this should not happen.
        return null;
    }

    var currentLanguage = primaryArg[0].settings.currentLanguage;
    if (!currentLanguage) {
        // if no current language was provided, return null; this should not happen.
        return null;
    }

    var result = gpii.macos.updateLanguage(currentLanguage);

    if (result.value == null) {
        return null;
    } else {
        // populate our result with a successful response (according to the standard Fluid response format)
        // NOTE: as of 2020-02-22, the Windows setting handler does not return the newValue or oldValue in currentLanguage (and technically we could probably just omit "settings" completely)
        // NOTE: in the future, we may want to consider using fluid.set(...), etc. to populate this result (i.e. follow a same pattern as in nativeSettingsHandler.js)
        var promise = fluid.promise();
        let wrappedResult = {};
        wrappedResult[settingHandlerName] = [
            {
                settings: {
                    curentLanguage: result.value
                }
            }
        ];
        promise.resolve(wrappedResult);
        return promise;
    }
}

gpii.macos.updateLanguage.lastLanguage = gpii.macos.language.getDisplayLanguage();
